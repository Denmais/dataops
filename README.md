# README.md — Git/релизы/CI/CD/верификация для ML-модели

Ниже описаны выбранная Git-стратегия, релизный цикл, примеры коммитов и CHANGELOG.md, проектирование CI/CD, а также чек‑лист верификации (UV) перед релизом для проекта с ML‑моделью (например, прогноз оттока).

---

## 1) Выбор Git‑стратегии

### Выбранная стратегия: GitHub Flow

**Кратко о правилах:**
- Ветка main всегда в состоянии “готово к релизу” (green build).
- Любая работа ведётся в короткоживущих ветках feature/* (или fix/*), затем — Pull Request (PR) в main.
- Слияние в main возможно только после прохождения CI и ревью.
- Релизы фиксируются тегами vX.Y.Z в main (SemVer).

### Почему GitHub Flow подходит для команды ML‑проекта
**Гипотетические вводные:**
- Команда: 5–10 человек (Data Science, ML Engineering, Backend, QA/аналитик).
- Частота релизов: регулярные (например, 1–2 раза в месяц), плюс возможны срочные патчи (утечки данных, баги в препроцессинге).
- Критичность: средняя/высокая (модель влияет на бизнес‑решения; ошибки могут привести к финансовым потерям или рискам комплаенса).

**Обоснование:**
- GitHub Flow проще Git Flow: меньше “долгоживущих” веток и меньше операционной нагрузки, что важно при активных экспериментах DS.
- main всегда стабилен: это снижает риск “сломанных” релизов, упрощает откаты и поддержку продакшена.
- Удобен для частых небольших релизов и hotfix: патч‑ветка → PR → тег v1.0.1.
- Хорошо сочетается с обязательной автоматизацией проверок (CI) и код‑ревью.

---

## 2) Описание релизного цикла

### Общие соглашения
- Версионирование: SemVer (MAJOR.MINOR.PATCH).
- Теги релизов: v1.0.0, v1.0.1, …
- Артефакты: Docker‑образ (model-service), артефакт модели (например, model.pkl/model.onnx) и метаданные (например, model_card.md, metrics.json).
- Регистр модели: условный “Model Registry” (например, MLflow Model Registry / S3 + метаданные).

### 2.1 Выпуск первого релиза v1.0.0
**Шаги:**
1. Ветка разработки: feature/release-prep-v1.0.0 (если нужно собрать финальные правки) или несколько feature/* веток.
2. В PR в main включаем:
   - стабильный пайплайн препроцессинга (например, модуль src/preprocessing/*);
   - обучающий код (например, src/train.py);
   - инференс‑сервис (например, src/service/*, Dockerfile);
   - тесты, документацию, мониторинги (минимально).
3. CI должен пройти полностью (линтеры, тесты, сборка артефактов).
4. Ручной “Release Candidate” прогон:
   - обучение на контрольном датасете/снапшоте;
   - проверка метрик против порогов;
   - проверка воспроизводимости (фиксированные seed, версии зависимостей).
5. Слияние PR в main.
6. Создание тега v1.0.0 на коммите в main.
7. CD:
   - сборка и публикация Docker‑образа;
   - публикация артефакта модели в registry;
   - деплой в staging → smoke‑тесты → деплой в production.
8. Формирование релиз‑нот (CHANGELOG.md) и артефактов комплаенса (при необходимости).

### 2.2 Обнаружена утечка в данных (data leak) → патч v1.0.1
**Что происходит:**
1. Инцидент фиксируется: создаётся issue “Data leakage incident” с описанием (какой признак/таблица/временная утечка).
2. Немедленные меры:
   - блокируем дальнейшее обучение на подозрительных данных;
   - при необходимости делаем rollback сервиса на предыдущий безопасный тег (если утечка влияет на прод‑предсказания/комплаенс).
3. Техническое исправление в ветке fix/data-leakage:
   - удаляем/правим leaking‑признак (например, “признак из будущего”);
   - добавляем проверку валидации дат/сплитов (например, тест в tests/test_leakage.py);
   - обновляем документацию: почему утечка возникла и как предотвращается.
4. Переобучение модели на корректных данных (с тем же интерфейсом и контрактом выхода).
5. PR → ревью → CI.
6. Тег v1.0.1 на main.
7. CD:
   - деплой патча (обычно без изменений API/контрактов);
   - мониторинг качества после деплоя (метрики/дрейф/алерты).

**Почему это PATCH:** поведение модели корректируется из‑за бага в данных/пайплайне, контракт выхода не меняется.

### 2.3 Новый мощный признак улучшает метрики → минор v1.1.0
**Что происходит:**
1. DS делает эксперимент в ветке feature/new-feature-xyz.
2. Добавляются:
   - новый признак в src/features/*;
   - обновление Feature Store/витрины (если есть);
   - тесты на корректность расчёта признака;
   - обновлённые метрики и “model card”.
3. Обязательные проверки:
   - отсутствие утечки (в т.ч. временной);
   - стабильность на срезах (популяции/каналы/регионы);
   - performance/regression тест на инференс (время ответа, память).
4. Совместимость:
   - вход/выход модели и API не ломаются;
   - добавление признака прозрачно для потребителей (это внутреннее улучшение).
5. PR → CI → merge.
6. Тег v1.1.0.
7. Деплой:
   - staging → A/B (или shadow) → production;
   - включение мониторинга сравнения с предыдущей версией (quality gates).

**Почему это MINOR:** функциональность/качество улучшается, но обратная совместимость сохраняется.

### 2.4 Бизнес меняет выход модели (добавить “причину” оттока) → мажор v2.0.0
**Что происходит:**
1. Обсуждение контракта и миграции:
   - фиксируем новый контракт ответа (например, probability + reason_code + reason_confidence);
   - описываем версионирование API (/v1/predict и /v2/predict).
2. Реализация в ветке feature/v2-output-schema:
   - обновляем инференс‑сервис (src/service/api.py);
   - обновляем схему (openapi.yaml или аналог);
   - добавляем/обновляем интеграционные тесты контрактов.
3. Стратегия выката без простоя:
   - параллельный запуск v1 и v2 (canary / blue‑green);
   - период “dual‑write/dual‑serve” (по возможности), чтобы потребители мигрировали.
4. Коммуникация:
   - релиз‑ноты с breaking changes;
   - дедлайн отключения v1.
5. Тег v2.0.0 и деплой.
6. После миграционного периода — выключаем v1 (если принято).

**Почему это MAJOR:** ломается контракт выхода/интеграция для потребителей.

---

## 3) Примеры сообщений коммитов и CHANGELOG.md

### 3.1 Примеры сообщений коммитов (Conventional Commits)
- feat: feat: add recency feature based on last_login_date
- fix: fix: prevent target leakage by excluding post-churn events from features
- docs: docs: document training dataset snapshot policy and retention
- refactor: refactor: extract preprocessing pipeline into Preprocessor class

### 3.2 Пример CHANGELOG.md (фрагмент)
Содержимое файла CHANGELOG.md:


